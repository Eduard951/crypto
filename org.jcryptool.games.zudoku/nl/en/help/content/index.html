<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Zudo-Ku</title>
	</head>
	
	<script type="text/javascript">
	function toggleVisibility(element) {
		if(element.style.display=='none') {
			element.style.display=''
		}else{
			element.style.display='none'
		}
	}
	
	</script>
<body>
	<h1>About Zudo-Ku</h1>
	
	<p>
	 	The computer tries to convince you that it has solved a 2x2 <a href="http://en.wikipedia.org/wiki/Sudoku" target="_blank">Sudoku</a>
	 	without showing you the actual numbers in the boxes. Zudo-Ku is a simple example of a
	 	<a href="http://en.wikipedia.org/wiki/Zero-knowledge_proof" target="_blank">zero-knowledge protocol</a>.
	</p>
	
	<h1>How to play</h1>
	When starting a new game, the computer solves a Sudoku game. It shows you only one initial starting number per 2x2
	subgrid. The rest is hidden from you.
	<p>
		Click on <b>Challenge</b> and pick a row, a column, or a block.
	</p>
	<p>
		The cards of the respective row/colum/block will be shuffled face down and then exposed to you. If the computer
		really has a correct solution, then those four cards must always include the numbers from 1 to 4 exactly once.
		Check whether the numbers are correct or the computer cheated you! 
		After checking, the computer covers the cards again, shuffles them, and returns them to the board as they were
		before. 
	</p>
	<p>
		Every time you click on <b>Let the Computer Cheat</b> the computer will add a wrong number to the Sudoku.
		Since the numbers are hidden, you do not know which one.
		How many times do you have to challenge the computer until you bust it?
	</p>
	<p>
		Most zero knowledge protocols are based on repeating steps. Every time you challenge the computer
		the probability of revealing the truth (correctly solved vs incorrectly solved) increases.

		Challenge the computer multiple times.
	</p>
	 <ul>
  		<li>How many challenges are necessary until you believe that it knows a correct solution of the Sudoku?</li>
  		<li>How could the computer fool you?</li>
  		<li>What information about the solution did the computer expose to you to convince you?</li>
  		<li>What information did the computer not expose to you?</li>
	</ul> 
	<p>		
		  Try to find a solution yourself just by using the facts you learned while challenging the computer.
		  You can also find some answers if you continue to read below. 
	</p>
	<p>
		
	</p>

	<h1>Background</h1>
	<p>
		Zero-Knowledge proofs and protocols are a special part of cryptography. The basic idea is that a party wants to
		prove it has some information, without revealing it (<b>Prover</b>). Another party (<b>Verifier</b>) wants to make
		sure you actually have that information, that it is correct and you are not only pretending to possess the piece
		of information.<br>
		Imagine you want to buy a car. The salesperson wants you to prove you have enough money to buy it. But you don't
		want to reveal how much money is on your bank account to a complete stranger. As a smart cryptologist you know,
		that you could use a zero-knowledge proof to show that you have enough money to buy the car, but not reveal how
		much you actually have.<br>
		Such protocols mostly rely on multiple iterations, just as the Zudo-ku game. With every correctly verified step
		the chances increase, that the Prover is actually in possession of the relevant information.
		
		There are 3 properties important for zero-knowledge protocols:
	</p>
	 <ul>
  		<li><b>Completeness:</b> If both parties of the protocol are honest, a verifier can be convinced of the statement</li>
  		<li><b>Soundness:</b> A cheating prover can hardly convince an honest prover of a false statement (since this often depends on probabilities, we cannot be certain)</li>
  		<li><b>Zero-knowledge:</b> The verifier can learn nothing about the statement except that it is true or false</li>
	</ul> 
	<h3 id="persona">Playing in person</h3>
	<p>
		The idea of this game can be applied even better in real life!<br>
		In the <b>simple variant</b>: take 81 cards with Numbers from 1-9 or and take a Sudoku riddle.
		The prover may or may not solve it but puts every card face down. 
		Either way she tries to convince the other person that she does have a correct solution. The verifying person
		selects exclusively rows, or columns or subgrids. She then takes the cards, shuffles them and looks at the
		numbers. If they are 1-9 it is ok. Putting them back as in this game is in real life not really feasable.
		This leads to a soundness (probability that the prover is caught cheating) with a probability of â‰¥ 1/3.<br>
		In the <b>extended variant</b> you take packs of 3 cards for each cell. By doing it this way, the verifier can
		check all rows, columns and subgrids. Note that thiss allows the prover to cheat with the 3 card packs for each cell. So
		she could not place {3,3,3} on a cell as expected, but e.g. {3,3,4}. Nevertheless the soundness improves to 8/9.
	</p>
	<h3>Answers to the questions above</h3>
	<p>
		For more detailed explanations take a look at the underlying paper! <a href="#1">[1]</a>
	</p>
	
	How many challenges are necessary until you believe that the computer knows a correct solution of the Sudoku?<br>
	<button title="Click to show/hide content" type="button" onclick="toggleVisibility(spoiler0)">Show/hide</button>
	<div id="spoiler0" style="display:none">
		If the computer honestly shuffles packs and shows each card, and the verifier checks each possibility,
		we have what we call Perfect completeness.<br>
		If the verifier does not trust the prover we have to look at the soundness - here it gets more complicated:
		In this example you can only verify that the computer shuffles, reveals and puts back the cards correctly by
		looking at the program code.
		If you play in person  you could watch the other person shuffling. You
		cannot put the cards back after shuffling, so you either use 1 set of cards and check one topology exclusively.
		So only rows, or only subgrids, or only columns.  <br>
		Alternatively you use packs of 3 cards for each cell so you can check
		multiple times. Now the prover can only cheat by not using the same 3 cards for a unique cell. This leads to a
		soundness of 8/9.
		There are also possibilities to achieve perfect soundness.
	</div>
	<br>
	<hr>
	How could the computer fool you?<br>
	<button title="Click to show/hide content" type="button" onclick="toggleVisibility(spoiler1)">Show/hide</button>
	<div id="spoiler1" style="display:none"> 
		The computer could just not have a correct solution as shown in this game. Then you can quite easily bust it.
		If it was more clever, it could try to manipulate the way it takes and puts the cards from the table.<br>
		If you play it in person, it depends if you play with one card per cell or with 3 cards per cell. If you played
		with 3 cards the prover can also manipulate the stacks of cards.
	</div>
	<br>
	<hr>
	What information about the solution did the computer expose to you to convince you - what did it not expose?<br>
	<button title="Click to show/hide content" type="button" onclick="toggleVisibility(spoiler2)">Show/hide</button>
	<div id="spoiler2" style="display:none"> 
		The computer only ever reveals a block of numbers which are can be checked against the games rules.
		Since those cards are randomly shuffled. One cannot find out the structure of the Sudoku by only looking at the
		shuffled cards - therefore it's a zero-knowledge protocol.
	</div>
	
	
	
	<h1>References</h1>
	<p id ="1">
		[1] Zudo-Ku was initially created for the <a href="http://www.kryptologikum.de/" target="_blank">Kryptologikum</a> and implements the ideas presented by Ronen Gradwohl, Moni Naor, Benny Pinkas and 
		Guy Rothblum in <a href="http://www.wisdom.weizmann.ac.il/~naor/PAPERS/sudoku_abs.html" target="_blank">"Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles"</a>.
	</p>
</body>
</html>
